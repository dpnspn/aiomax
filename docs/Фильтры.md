# Фильтры

> [!NOTE]
> На странице содержится термин `контент объекта`. Это:
>
> - `payload` для [`Callback`](Типы#callback)
> - Текст сообщения для [`Message`](Типы#message)
> - Старый текст (если закэширован, иначе `None`) для [`MessageDeletePayload`](Типы#messagedeletepayload)
> - Новый текст для [`MessageEditPayload`](Типы#messageeditpayload)
> - `args_raw` для [`CommandContext`](Типы#commandcontext)
> - `title` для [`ChatTitleEditPayload`](Типы#chattitleeditpayload)
> Если использовать фильтры, требующие контент с другими типами объектов, Вы получите ошибку

Фильтры - функции, которые помогают фильтровать ивенты, полученные через некоторые [декораторы](Декораторы).

Также фильтры можно применять ко всему роутеру сразу - больше на странице [Роутеры](Роутеры).

Фильтры могут выступать ввиде:

- строк - будут равны [`EqualsFilter`](#equalsfiltercontent-str)
- булинов, логических выражений - будут выполняться если значение равно True
- Функций - будут передавать объект,
 передаваемый декоратором (например: [`Message`](Типы#message) для декоратора [`on_message`](Декораторы#on_messagefilter-callable--str--none--none-detect_commands-bool--false))

## Встроенные фильтры

В подмодуле `aiomax.filters` имеются встроенные фильтры.

Пример использования встроенного фильтра (в данном случае [`StartsWithFilter`](#startswithfilterprefix-str)):

```py
@bot.on_message(aiomax.filters.StartsWithFilter('папайя'))
async def dialog(message: aiomax.Message):
    pass # Содержимое функции
```

### `EqualsFilter(content: str)`

Фильтр проверяет, чтобы контент был равен данной строке.

- `content` - строка, с которой нужно сравнить контент объекта

> [!TIP]
> Вместо этого фильтра можно ввести обычную строку

### `HasFilter(content: str)`

Фильтр проверяет, чтобы контент содержал в себе данную строку.

- `content` - строка, которая должна содержаться в контенте

### `StartsWithFilter(prefix: str)`

Фильтр проверяет, чтобы контент начинался с определенного префикса.

- `prefix` - строка, с которой должен начинаться контент

### `EndsWithFilter(suffix: str)`

Фильтр проверяет, чтобы контент заканчивался на определенный суффикс.

- `suffix` - строка, на которую должен заканчиваться контент

### `RegexFilter(pattern: str)`

Фильтр проверяет, чтобы контент соответствовал регулярному выражению.

- `pattern` - паттерн регулярного выражения

### `PapayaFilter()`

Проверяет, является ли предпоследнее слово в сообщении "папайя".

### `StateFilter(state: any)`

Проверяет, чтобы состояние пользователя (`State`) равнялось `state`. Подробнее на странице [FMS](FSM)

## Написание собственных фильтров

> [!NOTE]
> Фильтры могут быть как синхронные, так и асинхронные

При написании собственных фильтров у вас есть 3 варианта:

### Классы

Лучший вариант, т. к. поддерживает булевые операции (`&`, `|` для операций `and` и `or` соответственно), если дочерний встроенному классу `BaseFilter`

Пример фильтра, принимающего тип чата и проверяющего, что сообщение отправлено именно в чате этого типа:

```py
class ChatTypeFilter(BaseFilter):
    def __init__(self, chat_type):
        self.chat_type = chat_type

    def __call__(self, message: aiomax.Message):
        return message.recipient.chat_type == self.chat_type

@bot.on_message(ChatTypeFilter('dialog'))
async def dialog(message: aiomax.Message):
    pass # Содержимое функции
```

### lambda-выражения

Самый короткий вариант для небольших фильтров. Пишется чаще всего в одну строку.

Пример для проверки на то, что сообщение отправлено в ЛС боту:

```py
@bot.on_message(lambda message: message.recipient.chat_type == 'dialog')
async def dialog(message: aiomax.Message):
    pass # Содержимое функции
```

### Функции

`def` функции длиннее, но могут использоваться в несколько строк

Пример для проверки на то, что сообщение отправлено в ЛС боту:

```py
def in_dialog(message: aiomax.Message):
    return message.recipient.chat_type == 'dialog'

@bot.on_message(in_dialog) # Обратите внимание, что вызывать функцию не нужно!
async def dialog(message: aiomax.Message):
    pass # Содержимое функции
```

## Использование нескольких фильтров

> [NOTE]
> Если хотя бы один из используемых фильтров - дочерний классу `BaseFilter`, Вам может быть удобнее использовать [Магию](#магическое-использование-нескольких-фильтров)

Вы можете указать несколько фильтров в декораторах, где они поддерживаются, передавая их через запятую.

Это позволяет комбинировать различные условия без необходимости писать сложные фильтры вручную.
По умолчанию используется логика `AND`: обработчик сработает только в случае, если все фильтры вернули True.

```py
@bot.on_message(
    aiomax.filters.startswith("привет"),
    aiomax.filters.endwith("hello"),
)
async def bot_check(message: aiomax.Message):
    await message.delete()
```

Если Вы хотите, чтобы обработчик срабатывал если только один любой указанный фильтр вернет True, укажите параметр `mode='or'`:

```py
@bot.on_message(
    aiomax.filters.equals("привет"),
    aiomax.filters.equals("hello"),
    mode='or'
)
async def greetings(message: aiomax.Message):
    await message.reply("Добрый день! Good afternoon!")
```

## Магические методы фильтров

Магические методы - функции класса `BaseFilter`, используемые как операторы и позволяющие проводить логические операции с фильтрами, дочерними ему

> [!NOTE]
> Строки не работают с магическими фильтрами. Их можно заменить на [`EqualsFilter`](#equalsfiltercontent-str)

### Магическое использование нескольких фильтров

Поддерживаются побитовые операции `&` для логического И (and) и `|` для логического ИЛИ (or)

Проверка, чтобы оба фильтра возвращали `True`:

```py
@bot.on_message(
    lambda message: message.recipient.chat_id == 2409 &
    lambda message: not message.sender.is_bot
)
async def bot_check(message: aiomax.Message):
    await bot.delete_message(message.id)
```

Проверка на то, чтобы любой из указанных фильтров возвращал `True`:

```py
@bot.on_message(
    aiomax.filters.equals("привет") |
    aiomax.filters.equals("hello")
)
async def greetings(message: aiomax.Message):
    await message.reply("Добрый день! Good afternoon!")
```

### НЕ фильтр

Для проверки, чтобы фильтр возвращал `False`, Вы можете добавить минус (`-`) в начало фильтра дочернего классу `BaseFilter`:

В `BaseFilter` (родительский объект всех встроенных фильтров) добавлена функция для отрицания фильтров.

Этот фильтр проверяет, чтобы сообщение не начиналось на "aiomax":

```py
@bot.on_message(-aiomax.filters.startswith('aiomax'))
async def notaiomax(message: aiomax.Message):
    pass
```
